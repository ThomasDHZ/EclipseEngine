#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_debug_printf : enable

#include "MeshProperties.glsl"

layout(push_constant) uniform MeshInfo
{
    uint MeshIndex;
    mat4 proj;
    mat4 view;
    vec3 CameraPos;
    vec3 MeshColorID;
    vec3 AmbientLight;
    uint DirectionalLightCount;
    uint PointLightCount;
    uint SpotLightCount;
    float Timer;
} ConstMesh;

struct Vertex
{
	vec3 Position;
	float PositionPadding;
	vec3 Normal;
	float NormalPadding;
	vec2 UV;
	vec2 UVPadding;
	vec3 Tangant;
	float TangantPadding;
	vec3 BiTangant;
	float BiTangentPadding;
	vec3 Color;
	float ColorPadding;
 };

 struct Bones
 {
 	ivec4 BoneID;
	vec4  BoneWeights;
 };

layout(binding = 0, scalar) buffer Vertices { Vertex v[]; }vertices;
layout(binding = 1, scalar) buffer Bonesz { Bones b[]; }bone;
layout(binding = 2) buffer MeshPropertiesBuffer { MeshProperties meshProperties; } meshBuffer[];
layout(binding = 3, scalar) buffer BoneTransform { mat4 Transform[]; } MeshBoneTransform;

void main()
{
  Vertex v0 = vertices.v[gl_GlobalInvocationID.x];
  Bones b = bone.b[gl_GlobalInvocationID.x];

  mat4 BoneTransform = mat4(1.0f);
  BoneTransform =  MeshBoneTransform.Transform[b.BoneID[0]] * b.BoneWeights[0];
  BoneTransform += MeshBoneTransform.Transform[b.BoneID[1]] * b.BoneWeights[1];
  BoneTransform += MeshBoneTransform.Transform[b.BoneID[2]] * b.BoneWeights[2];
  BoneTransform += MeshBoneTransform.Transform[b.BoneID[3]] * b.BoneWeights[3];
  vec4 BonePosition = BoneTransform * vec4(v0.Position, 1.0);

  v0.Position = vec3(meshBuffer[0].meshProperties.MeshTransform *  BonePosition);
  v0.Normal = normalize(transpose(inverse(mat3(meshBuffer[0].meshProperties.MeshTransform * BoneTransform))) * v0.Normal);
  vertices.v[gl_GlobalInvocationID.x] = v0;
}